<html>
<head></head>

<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  <style>
    .results {
      background-color: #fafafa;
      padding-left: 10px;
      padding-right: 10px;
      border-radius: 3px;
    }
    #result-table {
      margin-top: 20px;
      border-radius: 3px;
    }
    .form-group {
      margin-top: 30px;
    }
    .btn-primary {
      margin-top: 10px;
    }
  </style>


<script src="math.js"></script>
<script src="c.js"></script>
<script src="c.min.js"></script>

<script>


/**
 * general topological sort
 * @author SHIN Suzuki (shinout310@gmail.com)
 * @param Array<Array> edges : list of edges. each edge forms Array<ID,ID> e.g. [12 , 3]
 *
 * @returns Array : topological sorted list of IDs
 **/

function tsort(edges) {
  var nodes   = {}, // hash: stringified id of the node => { id: id, afters: lisf of ids }
      sorted  = [], // sorted list of IDs ( returned value )
      visited = {}; // hash: id of already visited node => true

  var Node = function(id) {
    this.id = id;
    this.afters = [];
  }

  // 1. build data structures
  edges.forEach(function(v) {
    var from = v[0], to = v[1];
    if (!nodes[from]) nodes[from] = new Node(from);
    if (!nodes[to]) nodes[to]     = new Node(to);
    nodes[from].afters.push(to);
  });

  // 2. topological sort
  Object.keys(nodes).forEach(function visit(idstr, ancestors) {
    var node = nodes[idstr],
        id   = node.id;

    // if already exists, do nothing
    if (visited[idstr]) return;

    if (!Array.isArray(ancestors)) ancestors = [];

    ancestors.push(id);

    visited[idstr] = true;

    node.afters.forEach(function(afterID) {
      if (ancestors.indexOf(afterID) >= 0)  // if already in ancestors, a closed chain exists.
        throw new Error('closed chain : ' +  afterID + ' is in ' + id);

      visit(afterID.toString(), ancestors.map(function(v) { return v })); // recursive call
    });

    sorted.unshift(id);
  });

  return sorted;
}


function topologicalSort(conditions)
{
	var conditionHash = {};
	var edges = [];

	for(var i = 0; i< conditions.length; i++)
	{
			if(conditions[0]=="'") {
				continue;
			}

				var components = splitToExpr(conditions[i]);
			    if (components.length != 2 ) {
					return false;
				}


				if(components[1]=="?") {
					continue;
				}


			var node = math.parse(components[1])

			var condition = { "var" : components[0] , "cond" : conditions[i]};


				node.traverse(function (tnode, path, parent) {
  		
					if(tnode.type == "SymbolNode") {

						edges.push([condition["var"],tnode.name]);
					}
		});
		
  		}




	

	try {
			var sorted = tsort(edges);
			var topologicalSorted = [];

			for(var i = 0; i < sorted.length ; i ++) {

			topologicalSorted.push(conditionHash[sorted[i]]["cond"]);
			}

			return topologicalSorted;
	}
	catch(e) {
		return null;
	}
	

}

function splitToExpr(string)
{
	components = string.split("=")
	return components.map( function(element) { return element.trim()  });
}

function parseComponent(components)
{
	var node = math.parse(components[1])


	var variableName = components[0];
	var variable = variables[variableName];
	
	if(variable == null || variable == undefined) {

		variables[variableName] = new c.Variable({ value: 10 });
		variable = variables[variableName];
	}

	var stack = [];

	node.traverse(function (node, path, parent) {
  		
		if(node.type != "ParenthesisNode") {
			console.log(node.type);
			stack.push(node);	
		}
		
  		});
	

	var stackCopy = stack.slice();
	var invert = false;
	var inversionVariable = null;
	var divisionVariable = null;

	if(stackCopy.length > 1) {

			while(stackCopy.length > 1) {
				var op1 = stackCopy.pop();
				var op2 = stackCopy.pop();
				var op = stackCopy.pop();

				if(op.op == "/" && variables[op1.name] == undefined) {
					invert = true;
					inversionVariable = op1.name;
					break;
				}
				var expression = expressionFor(nodeForOperand(op2),nodeForOperand(op1),op);
				stackCopy.push(expression);
		
		}

	}


	if(invert) {

		divisionVariable = variable;
		variables[inversionVariable] = new c.Variable({ value: 10 });
		variable = variables[inversionVariable];

		console.log(" d "+divisionVariable.name+ " i "+inversionVariable)
	}

	// dumb hack .. fix ..
	if (stack.length == 1) {

		return [variable,nodeForOperand(stack[0])];
	}
	else {

			while(stack.length > 1) {

			var op1 = stack.pop();
			var op2 = stack.pop();
			var op = stack.pop();

			if(invert && op.op == "/" && op1.name == inversionVariable) {
				var expression = expressionFor(nodeForOperand(op2),new c.Expression(parseFloat(divisionVariable.value)) ,op);
			    stack.push(expression);
			    expression["divided"] = true;


			}
			else {

				if(invert) {

					var firstOp = op1;
					var secondOp = op2;

					if(op1["divided"] == undefined && (op.op == "+" || op.op == "-" )) {

						firstOp = expressionFor(op1,new c.Expression(parseFloat(divisionVariable.value)),"/");
					}

					if(op2["divided"] == undefined && (op.op == "+" || op.op == "-" )) {

						secondOp = expressionFor(op2,new c.Expression(parseFloat(divisionVariable.value)),"/");
					}

				var expression = expressionFor(firstOp,secondOp,op);
			    stack.push(expression);
			    expression["divided"] = true;



				}
				else {

				var expression = expressionFor(nodeForOperand(op2),nodeForOperand(op1),op);
			    stack.push(expression);


				}

			}
		
	}


	}


	return [variable,stack[0]];
}

function expressionFor(op1,op2,operand)
{
	if(operand.op == "+") {
		return op1.plus(op2);
	}

	else if(operand.op == "*") {
		return op1.times(op2);
	}
	else if(operand.op == "-") {
		return op1.minus(op2);
	}
	else if(operand.op == "/") {
		return op1.divide(op2);
	}
}

function nodeForOperand(node)
{
		// hack hack
		if(node["type"] == null || node["type"] == undefined) {
			return node;
		}

		switch (node.type) {
    		case 'ConstantNode': 
    			return new c.Expression(parseFloat(node.value)); 
    			break;
    		case 'SymbolNode':   
    		    if(variables[node.name]) {
    		      return new c.Expression(variables[node.name].value);	
    		    }
    		    else {

    		       variables[node.name] = new c.Variable({ value: 10 });
			       return new c.Expression(variables[node.name]);	


    		    }
    			
    			break;
    		default:             
				return null;
			}
}

var cS = new c.SimplexSolver();
var variables = {};

function parseCondition(condition)
{
	if(condition[0]=="'") {
		return true;
	}

	var components = splitToExpr(condition)
	if (components.length != 2 ) {
		return false;
	}


	if(components[1]=="?") {
		return true;
	}



	var node = parseComponent(components);


	var equation = new c.Equation(node[0],node[1]);
	cS.addConstraint(equation);

	return true;

	if(node.value != undefined) {
		console.log(variableName + " is "+ node.value);
	}
	else {

	}

}

function processConditions(text)
{
	cS = new c.SimplexSolver();
	variables = {};

	var sortedConditions = topologicalSort(text);

	if (sortedConditions==null) {
			document.getElementById("results-table").innerHTML = "Cyclic dependency detected";
			return;

	}

	for(var i = 0; i< text.length; i ++) {

		if(!parseCondition(text[i])) {

			document.getElementById("results-table").innerHTML = "Please check your expressions.";
			return;
		}
	}

	cS.solve();

	var results = [];
	var keys = Object.keys(variables);

	for(var i = 0 ; i < keys.length; i++)
	{
		results.push(keys[i] + " : "+variables[keys[i]]);
	}

	var resultText = results.join("<br/>");

	document.getElementById("results-table").innerHTML = resultText;

}

document.addEventListener("DOMContentLoaded", function(event) {
    
    var area = document.getElementById("textArea");

    area.value = "'This is a demo of a cool tool you can use to play with numbers \n\
'As you can see you can start a comment with a ' character and intermingle explanations.\n\
'It's still very buggy though :)\n\
'Let us examine a use case. Let us analyse the demonetisation exercise\n\n\
'Let us define a variable\n\
'Number of five hundreds we need in crores\n\
fiveHundredNotesNeeded = 1971\n\
twoThousandNotesNeeded = 316\n\
totalNotesNeeded = fiveHundredNotesNeeded + twoThousandNotesNeeded\n\
rbiCapacityPerMonth=200\n\
'monthsForTotalReplacement =  2\n\
monthsForTotalReplacement = totalNotesNeeded/rbiCapacityPerMonth\n\
\n\
' So we need 11.435 months. \n\
' Now let us see how much capacity we need to replace it in two months\n\
' Uncomment the monthsForTotalReplacement=2 and change the 200 for rbiCapacityPerMonth to a \"?\""
if (area.addEventListener) {
  area.addEventListener('input', function() {
    
    var text = area.value;
    processConditions(text.split("\n").filter(function (element) { return element.trim().length > 0; }));



  }, false);
}


    var text = area.value;
    processConditions(text.split("\n").filter(function (element) { return element.trim().length > 0; }));
  });

</script>

<title> Expression parser </title>

<body>

 <div class="container">
      <div class="row">
        <div class="col-xs-6 col-sm-offset-3">

<h2> Input </h2>

<textarea rows="20" cols="50" id="textArea" class="form-control">

</textarea>


<div class="results">
		<h3> Results </h3>
		<div id="results-table">
		</div>
<div>
</div></div></div>

</body>


</html>